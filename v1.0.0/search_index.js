var documenterSearchIndex = {"docs":
[{"location":"release-notes/#Release-notes","page":"Release Notes","title":"Release notes","text":"","category":"section"},{"location":"release-notes/","page":"Release Notes","title":"Release Notes","text":"The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.","category":"page"},{"location":"release-notes/#Version-[v1.0.0](https://github.com/JuliaArrays/FixedSizeArrays.jl/releases/tag/v1.0.0)-2025-06-04","page":"Release Notes","title":"Version v1.0.0 - 2025-06-04","text":"","category":"section"},{"location":"release-notes/","page":"Release Notes","title":"Release Notes","text":"Initial release.","category":"page"},{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"usage/#The-FixedSizeArray-type","page":"Usage","title":"The FixedSizeArray type","text":"","category":"section"},{"location":"usage/#Constructors","page":"Usage","title":"Constructors","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"The basic type provided by this package is FixedSizeArray. Its constructor uses a similar syntax to Base's Array:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using FixedSizeArrays\nv = FixedSizeArray{Float64}(undef, 3)\nM = FixedSizeArray{Float64}(undef, 2, 2)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"You can also construct FixedSizeArrays from other arrays:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"julia> using FixedSizeArrays\n\njulia> arr = [10 20; 30 14]\n2×2 Matrix{Int64}:\n 10  20\n 30  14\n\njulia> FixedSizeArray(arr)  # construct from an `AbstractArray` value\n2×2 FixedSizeArray{Int64, 2, Memory{Int64}}:\n 10  20\n 30  14\n\njulia> FixedSizeArray{Float64}(arr)  # construct from an `AbstractArray` value while converting element type\n2×2 FixedSizeArray{Float64, 2, Memory{Float64}}:\n 10.0  20.0\n 30.0  14.0","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"For 1- and 2-dimensional arrays you can use the aliases FixedSizeVector and FixedSizeMatrix, respectively:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using FixedSizeArrays\nv = FixedSizeVector{Float64}(undef, 2)\nM = FixedSizeMatrix{Float64}(undef, 3, 3)","category":"page"},{"location":"usage/#The-memory-backend","page":"Usage","title":"The memory backend","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"The FixedSizeArray{T,N,Mem} type has three parameters:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"T: the type of the elements of the array (e.g. Int64 or Float64);\nN: the number of dimensions of the array (e.g. 1 for a vector, 2 for a matrix);\nMem<:DenseVector{T}: the memory backend.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"note: Implementation details\nIn Julia v1.11+, the default memory backend is the Memory{T} type. Since Julia v1.10 does not have the Memory type, to make this package usable also on Julia v1.10 Vector{T} is used as memory backend, but many of the memory/performance optimizations enabled by this package will not be available in that version of Julia and in general FixedSizeArrays.jl does not provide significant improvements compared to Base's Array for that specific version.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"To make it easier to refer to the concrete type FixedSizeArray{T,N,Mem} with the default memory backend, the following convenient aliases are available:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"FixedSizeArrayDefault{T,N};\nFixedSizeVectorDefault{T};\nFixedSizeMatrixDefault{T}.","category":"page"},{"location":"usage/#The-collect_as-utility","page":"Usage","title":"The collect_as utility","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"The array literals syntax [A, B, C, ...] to construct arrays is limited to Base's Array and cannot be extended to custom array types. The package Collects.jl provides a convenient function, collect_as, to overcome this limitation and construct FixedSizeArrays out of any iterable:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"julia> iter = (i for i ∈ 7:9 if i≠8);\n\njulia> using FixedSizeArrays, Collects\n\njulia> collect_as(FixedSizeArray, iter)  # construct from an arbitrary iterator\n2-element FixedSizeArray{Int64, 1, Memory{Int64}}:\n 7\n 9\n\njulia> collect_as(FixedSizeArray{Float64}, iter)  # construct from an arbitrary iterator while converting element type\n2-element FixedSizeArray{Float64, 1, Memory{Float64}}:\n 7.0\n 9.0\n\njulia> collect_as(FixedSizeVectorDefault, (3.14, -4.2, 2.68))  # construct from a tuple\n3-element FixedSizeArray{Float64, 1, Memory{Float64}}:\n  3.14\n -4.2\n  2.68","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"See the Collects.jl Readme for more information.","category":"page"},{"location":"usage/#BoundsErrorLight-exception","page":"Usage","title":"BoundsErrorLight exception","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"To facilitate the escape analysis of FixedSizeArrays, accessing an out-of-bound index of these arrays raises a BoundsErrorLight exception when possible. This exception type does not store the entire array for reporting the error message, thus enabling more performance optimizations compared to arrays which throw BoundsError exceptions.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"warning: Compatibility of exception raised\nWe do not guarantee to throw either BoundsError or BoundsErrorLight when accessing an out-of-bound index of a FixedSizeArray. The exact exception raised may change at any point without breaking the semantic versioning compatibility contract.","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"The latest version of FixedSizeArrays.jl is available for Julia v1.10 and later releases, and can be installed with Julia built-in package manager. In the Julia REPL, after entering the package manager mode with ], run the command","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"pkg> update\npkg> add FixedSizeArrays","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/#Public-API","page":"Reference","title":"Public API","text":"","category":"section"},{"location":"reference/#FixedSizeArrays.FixedSizeArray","page":"Reference","title":"FixedSizeArrays.FixedSizeArray","text":"FixedSizeArray{T,N,Mem<:DenseVector{T}}(undef, size::NTuple{N,Int})\nFixedSizeArray{T,N,Mem<:DenseVector{T}}(undef, size1::Int, size2::Int, ...)\nFixedSizeArray{T,N,Mem<:DenseVector{T}}(array::AbstractArray)\n\nConstruct a fixed-size FixedSizeArray with element type T, number of dimensions N, and memory backend Mem.\n\nConvenient aliases provided:\n\nFixedSizeVector{T,Mem}: for 1-dimensional fixed-size arrays\nFixedSizeMatrix{T,Mem}: for 2-dimensional fixed-size arrays\nFixedSizeArrayDefault{T,N}: for N-dimensional fixed-size arrays, with default memory backend\nFixedSizeVectorDefault{T}: for 1-dimensional fixed-size arrays, with default memory backend\nFixedSizeMatrixDefault{T}: for 2-dimensional fixed-size arrays, with default memory backend\n\n\n\n\n\n","category":"type"},{"location":"reference/#FixedSizeArrays.FixedSizeVector","page":"Reference","title":"FixedSizeArrays.FixedSizeVector","text":"FixedSizeVector{T,Mem<:DenseVector{T}}(undef, size::NTuple{1,Int})\nFixedSizeVector{T,Mem<:DenseVector{T}}(undef, size1::Int)\nFixedSizeVector{T,Mem<:DenseVector{T}}(array::AbstractVector)\n\nConstruct a fixed-size 1-dimensional FixedSizeArray with element type T, and memory backend Mem.\n\nConvenient aliases provided:\n\nFixedSizeVectorDefault{T}: for 1-dimensional fixed-size arrays, with default memory backend\n\n\n\n\n\n","category":"type"},{"location":"reference/#FixedSizeArrays.FixedSizeMatrix","page":"Reference","title":"FixedSizeArrays.FixedSizeMatrix","text":"FixedSizeMatrix{T,Mem<:DenseMatrix{T}}(undef, size::NTuple{2,Int})\nFixedSizeMatrix{T,Mem<:DenseMatrix{T}}(undef, size1::Int, size2::Int)\nFixedSizeMatrix{T,Mem<:DenseMatrix{T}}(array::AbstractMatrix)\n\nConstruct a fixed-size 2-dimensional FixedSizeArray with element type T, and memory backend Mem.\n\nConvenient aliases provided:\n\nFixedSizeMatrixDefault{T}: for 2-dimensional fixed-size arrays, with default memory backend\n\n\n\n\n\n","category":"type"},{"location":"reference/#FixedSizeArrays.FixedSizeArrayDefault","page":"Reference","title":"FixedSizeArrays.FixedSizeArrayDefault","text":"FixedSizeArrayDefault{T,N}(undef, size::NTuple{N,Int})\nFixedSizeArrayDefault{T,N}(undef, size1::Int, size2::Int, ...)\nFixedSizeArrayDefault{T,N}(array::AbstractArray)\n\nConstruct a FixedSizeArray with element type T, number of dimensions N, and the default memory backend (Vector{T} on Julia v1.10, Memory{T} on Julia v1.11+).\n\n\n\n\n\n","category":"type"},{"location":"reference/#FixedSizeArrays.FixedSizeVectorDefault","page":"Reference","title":"FixedSizeArrays.FixedSizeVectorDefault","text":"FixedSizeVectorDefault{T}(undef, size::NTuple{1,Int})\nFixedSizeVectorDefault{T}(undef, size1::Int)\nFixedSizeVectorDefault{T}(array::AbstractVector)\n\nConstruct a FixedSizeVector with element type T, and the default memory backend (Vector{T} on Julia v1.10, Memory{T} on Julia v1.11+).\n\n\n\n\n\n","category":"type"},{"location":"reference/#FixedSizeArrays.FixedSizeMatrixDefault","page":"Reference","title":"FixedSizeArrays.FixedSizeMatrixDefault","text":"FixedSizeMatrixDefault{T}(undef, size::NTuple{2,Int})\nFixedSizeMatrixDefault{T}(undef, size1::Int, size2::Int)\nFixedSizeMatrixDefault{T}(array::AbstractMatrix)\n\nConstruct a FixedSizeMatrix with element type T, and the default memory backend (Vector{T} on Julia v1.10, Memory{T} on Julia v1.11+).\n\n\n\n\n\n","category":"type"},{"location":"reference/#Base.parent","page":"Reference","title":"Base.parent","text":"parent(f::FixedSizeArray)\n\nReturn the underlying parent object of the fixed-size array f. Use parentindices(f) to get the valid indices of the parent of f.\n\n\n\n\n\n","category":"function"},{"location":"reference/#FixedSizeArrays.BoundsErrorLight","page":"Reference","title":"FixedSizeArrays.BoundsErrorLight","text":"BoundsErrorLight <: Exception\n\nLike BoundsError, but doesn't store the array, to prevent clashing with escape analysis.\n\nStores the type of the array and the shape instead.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Internal-API","page":"Reference","title":"Internal API","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"This section gathers documentation of internal functionalities of FixedSizeArrays.jl which are only of interest to the developers of and contributors to this package.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"warning: Warning\nThe following functionalities are not part of the public API of the package and should not be relied upon by external packages, as they can be modified or removed at any point without notice.","category":"page"},{"location":"reference/#FixedSizeArrays.with_stripped_type_parameters","page":"Reference","title":"FixedSizeArrays.with_stripped_type_parameters","text":"with_stripped_type_parameters(spec, t::Type)::Val{s}\n\nThe type s is a UnionAll supertype of t:\n\n(s isa UnionAll) && (t <: s)\n\nFurthermore, s has type variables in place of the type parameters specified via spec.\n\nNB: Val{s}() is returned instead of s so the method would be consistent from the point of view of Julia's effect inference, enabling constant folding.\n\nNB: this function is supposed to only have the one method. To add functionality, add methods to with_stripped_type_parameters_unchecked.\n\n\n\n\n\n","category":"function"},{"location":"reference/#FixedSizeArrays.with_stripped_type_parameters_unchecked","page":"Reference","title":"FixedSizeArrays.with_stripped_type_parameters_unchecked","text":"with_stripped_type_parameters_unchecked(spec, t::Type)::Val{s}\n\nAn implementation detail of with_stripped_type_parameters. Don't call directly.\n\n\n\n\n\n","category":"function"},{"location":"#FixedSizeArrays.jl","page":"Introduction","title":"FixedSizeArrays.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"FixedSizeArrays.jl is a package for the Julia programming language which implements mutable fixed-size arrays (FixedSizeArray), which means the length of the array can not change after construction and is amenable to be constant-propagated at compile-time when possible.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"FixedSizeArrays supports the standard array interfaces, so things like broadcasting, matrix multiplication, other linear algebra operations, similar, copyto! or map should just work.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Use the constructors to convert from other array types. Use collect_as from the Collects.jl package to convert from arbitrary iterators.","category":"page"},{"location":"#Comparison-with-other-array-types","page":"Introduction","title":"Comparison with other array types","text":"","category":"section"},{"location":"#Array-from-Base","page":"Introduction","title":"Array from Base","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"While Base's Array is a convenient multi-dimensional container for continuous data, a fixed-size array is what is employed in most linear algebra applications, where the size of tensors typically does not change. Here is a comparison between Array and FixedSizeArray:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Array is dynamic (or growable) which means the size of an Array can be changed after construction.  The size of a FixedSizeArray cannot be changed;\nthe above property of FixedSizeArrays enables certain compiler optimizations in some cases where the size of a FixedSizeArray is known at compile-time. The dynamic property of Arrays limits the optimization opportunities, which makes Arrays less likely to be optimized as efficiently as FixedSizeArrays.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"You can see a showcase of performance/memory advantages of FixedSizeArray over Array in this evolving discussion.","category":"page"},{"location":"#MArray-from-StaticArrays.jl","page":"Introduction","title":"MArray from StaticArrays.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"FixedSizeArray is an alternative implementation to MArray from StaticArrays.jl.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Main differences between FixedSizeArray and MArray are:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"FixedSizeArray is based on the Memory type introduced in Julia v1.11, MArray is backed by tuples, which are not efficient for long arrays (gg 100 elements);\nthe size of the array is part of the type parameters of MArray, this isn't the case for FixedSizeArray, where the size is only a constant field of the data structure.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"There are applications where it may be desirable to dispatch on the size of an array, in that case FixedSizeArray would not be a good fit and you may consider using MArray instead.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"FixedSizeArray is not a direct replacement for SArray: in addition to having the size as part of the type parameters, SArray is immutable, instead the elements of a FixedSizeArray can be changed at any point.","category":"page"},{"location":"#What-about-the-other-package-with-same-name?","page":"Introduction","title":"What about the other package with same name?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package is not related to a package with the same name by @SimonDanisch. That, earlier, package was one of the StaticArrays.jl-like packages in the pre-v1 days of Julia: https://github.com/SimonDanisch/FixedSizeArrays.jl.","category":"page"}]
}
